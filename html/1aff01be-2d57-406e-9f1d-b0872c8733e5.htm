<html xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp"><head><link rel="SHORTCUT ICON" href="./../icons/favicon.ico" /><style type="text/css">.OH_CodeSnippetContainerTabLeftActive, .OH_CodeSnippetContainerTabLeft,.OH_CodeSnippetContainerTabLeftDisabled { }.OH_CodeSnippetContainerTabRightActive, .OH_CodeSnippetContainerTabRight,.OH_CodeSnippetContainerTabRightDisabled { }.OH_footer { }</style><link rel="stylesheet" type="text/css" href="./../styles/branding.css" /><link rel="stylesheet" type="text/css" href="./../styles/branding-en-US.css" /><style type="text/css">
			body
			{
			border-left:5px solid #e6e6e6;
			overflow-x:scroll;
			overflow-y:scroll;
			}
		</style><script src="./../scripts/branding.js" type="text/javascript"><!----></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Implementing a custom Naiad vertex</title><meta name="Language" content="en-us" /><meta name="Microsoft.Help.Id" content="1aff01be-2d57-406e-9f1d-b0872c8733e5" /><meta name="Description" content="Naiad programs are described as dataflow graphs, where the nodes in the graph (Naiad calls them stages) correspond to computation, and the edges describe the flow of data." /><meta name="Microsoft.Help.ContentType" content="How To" /><meta name="BrandingAware" content="'true'" /><link type="text/css" rel="stylesheet" href="./../styles/highlight.css" /><script type="text/javascript" src="../scripts/highlight.js"><!----></script><meta name="SelfBranded" content="true" /></head><body onload="onLoad()" class="primary-mtps-offline-document"><div class="OH_outerDiv"><div class="OH_outerContent"><table class="TitleTable"><tr><td class="OH_tdLogoColumn"><img src="./../icons/Help.png" /></td><td class="OH_tdTitleColumn">Implementing a custom Naiad vertex</td><td class="OH_tdRunningTitleColumn">Naiad Help</td></tr></table><div id="mainSection"><div id="mainBody"><span class="introStyle"></span><p style="color: #dc143c; font-size: 8.5pt; font-weight: bold;">[This is preliminary documentation and is subject to change.]</p><div class="introduction"><p>
        Naiad programs are described as dataflow graphs, where the nodes in the graph (Naiad calls them stages) correspond to computation, and the edges describe the flow of data. A large collection of pre-fabricated stages exist, and while most programmers will likely use these predominantly, it can also be useful to be able to understand how stages are defined in case the programmer needs to introduce custom computations.
      </p><p>
        There are two steps to implementing a custom dataflow stage: one needs to define a dataflow vertex containing the associated state and logic, and one needs to tell Naiad how to connect inputs and outputs to this logic so that input records trigger the correct computation. We will go through each of these parts, demonstrating not only how to perform these steps from the ground up, but also how Naiad has wrapped up some common patterns to try and make life easier for the programmer.
      </p></div><div class="OH_CollapsibleAreaRegion"><div class="OH_regiontitle">Defining the dataflow vertex</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"></div><p>
          Custom vertices are defined by inheriting from the <span sdata="cer" target="T:Microsoft.Research.Naiad.Dataflow.Vertex`1"><a href="T_Microsoft_Research_Naiad_Dataflow_Vertex_1.htm" target="">Vertex<span id="ID0ECADCBAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0ECADCBAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>TTime<span id="ID0EAADCBAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EAADCBAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script></a></span> class,
          which is a class wrapping the common logic for all vertices that may be brought in to existence in a Naiad stage.
          The generic parameter  <span class="code">TTime</span>  denotes the type of Naiad timestamp the vertex uses, which will often be a generic parameter
          for your custom vertex, too. We'll get to the specific features of the Vertex class later.
          An example vertex with one input and one output might look like the following
        </p><div id="ID0EBBAAAAA" class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs" id="ID0EBBAAAAA_tabs"></div><div id="ID0EBBAAAAA_codecollection" class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EBBAAAAA_ViewColorized" href="#" onclick="javascript:ExchangeTitleContent('ID0EBBAAAAA','4')" title="View Colorized" style="display: none">View Colorized</a><a id="ID0EBBAAAAA_copycode" href="#" onclick="javascript:CopyToClipboard('ID0EBBAAAAA','4')" title="Copy to Clipboard">Copy to Clipboard</a><a id="ID0EBBAAAAA_PrintText" class="OH_PrintText" href="#" onclick="javascript:Print('ID0EBBAAAAA','4')" title="Print">Print</a></div></div><div id="ID0EBBAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre><span class="highlight-comment">// Single input, single output Naiad vertex. Each vertex must specify a time type.</span> 
<span class="highlight-keyword">public</span> <span class="highlight-keyword">class</span> ExampleVertex&lt;TRecord, TTime&gt; : Vertex&lt;TTime&gt;
    <span class="highlight-keyword">where</span> TTime : Time&lt;TTime&gt;
{
    <span class="highlight-comment">// each received message is simply forwarded to any listeners.</span> 
    <span class="highlight-keyword">public</span> <span class="highlight-keyword">void</span> OnReceive(Message&lt;TRecord, TTime&gt; message)
    {
        <span class="highlight-keyword">foreach</span> (<span class="highlight-keyword">var</span> listener <span class="highlight-keyword">in</span> <span class="highlight-keyword">this</span>.Listeners)
            recipient.Send(message);
    }

    <span class="highlight-comment">// list of output recipients, each of which require all sent records.</span> 
    <span class="highlight-keyword">public</span> <span class="highlight-keyword">readonly</span> List&lt;SendWire&lt;TRecord, TTime&gt;&gt; Listeners;

    <span class="highlight-comment">// each vertex requires its index in the stage, and the stage itself.</span> 
    <span class="highlight-keyword">public</span> ExampleVertex(<span class="highlight-keyword">int</span> index, Stage&lt;TTime&gt; stage)
        : <span class="highlight-keyword">base</span>(index, stage)
    {
        <span class="highlight-keyword">this</span>.Listeners = <span class="highlight-keyword">new</span> List&lt;SendWire&lt;TRecord, TTime&gt;&gt;();
    }
}</pre></div><div id="ID0EBBAAAAA_code_Plain_Div1" class="OH_CodeSnippetContainerCode" style="display: none"><pre>// Single input, single output Naiad vertex. Each vertex must specify a time type. 
public class ExampleVertex&lt;TRecord, TTime&gt; : Vertex&lt;TTime&gt;
    where TTime : Time&lt;TTime&gt;
{
    // each received message is simply forwarded to any listeners. 
    public void OnReceive(Message&lt;TRecord, TTime&gt; message)
    {
        foreach (var listener in this.Listeners)
            recipient.Send(message);
    }

    // list of output recipients, each of which require all sent records. 
    public readonly List&lt;SendWire&lt;TRecord, TTime&gt;&gt; Listeners;

    // each vertex requires its index in the stage, and the stage itself. 
    public ExampleVertex(int index, Stage&lt;TTime&gt; stage)
        : base(index, stage)
    {
        this.Listeners = new List&lt;SendWire&lt;TRecord, TTime&gt;&gt;();
    }
}</pre></div></div></div><script>addSpecificTextLanguageTagSet('ID0EBBAAAAA');</script><p>
          This vertex isn't especially interesting yet,
          and it isn't even clear how this list of recipients is populated. However, assuming that we sort that out, 
          the vertex's behavior is specified: for each received message, it sends that message to every one in its list of recipients.
        </p><div class="OH_CollapsibleAreaRegion"><div class="OH_regiontitle">Building a dataflow stage</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"></div><p>
          To complete this example, we have to assemble a stage consisting of many of these vertices, and describe how the inputs and outputs are connected.
          The standard pattern is to first create a new stage from a vertex factory, then add any number of inputs (defined by a message callback and partitioning
          requirement), and finally add any number of outputs (defined by a registration callback and partitioning guarantee). The example looks like:
        </p><div id="ID0EBAAAAAA" class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs" id="ID0EBAAAAAA_tabs"></div><div id="ID0EBAAAAAA_codecollection" class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EBAAAAAA_ViewColorized" href="#" onclick="javascript:ExchangeTitleContent('ID0EBAAAAAA','4')" title="View Colorized" style="display: none">View Colorized</a><a id="ID0EBAAAAAA_copycode" href="#" onclick="javascript:CopyToClipboard('ID0EBAAAAAA','4')" title="Copy to Clipboard">Copy to Clipboard</a><a id="ID0EBAAAAAA_PrintText" class="OH_PrintText" href="#" onclick="javascript:Print('ID0EBAAAAAA','4')" title="Print">Print</a></div></div><div id="ID0EBAAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre><span class="highlight-comment">// constructs a stage of our ExampleVertex, and returns the associated output stream.</span> 
<span class="highlight-keyword">public</span> <span class="highlight-keyword">static</span> Stream&lt;TRecord, TTime&gt; MakeStage(Stream&lt;TRecord, TTime&gt; stream,
                                                     Expression&lt;Func&lt;TRecord, <span class="highlight-keyword">int</span>&gt;&gt; inputPartitionBy,
                                                     Expression&lt;Func&lt;TRecord, <span class="highlight-keyword">int</span>&gt;&gt; outputPartitionBy,
                                                     <span class="highlight-keyword">string</span> name)
{
    <span class="highlight-comment">// first we define the innards of the stage, supplying a context, a vertex factory, and a friendly name.</span> 
    <span class="highlight-keyword">var</span> stage = Foundry.NewStage(stream.Context, (index, parent) =&gt; <span class="highlight-keyword">new</span> ExampleVertex&lt;TRecord, TTime&gt;(index, parent), name);

    <span class="highlight-comment">// each new input requires a source of data, a (message, vertex) callback, and a partitioning requirement.</span> 
    <span class="highlight-keyword">var</span> input = stage.NewInput(stream, (message, vertex) =&gt; vertex.OnReceive(message), inputPartitionBy);

    <span class="highlight-comment">// each new output requires a (listener, vertex) callback, and a partitioning guarantee.</span> 
    <span class="highlight-keyword">var</span> output = stage.NewOutput((listener, vertex) =&gt; vertex.Listeners.Add(listener), outputPartitionBy);

    <span class="highlight-keyword">return</span> output;
}</pre></div><div id="ID0EBAAAAAA_code_Plain_Div1" class="OH_CodeSnippetContainerCode" style="display: none"><pre>// constructs a stage of our ExampleVertex, and returns the associated output stream. 
public static Stream&lt;TRecord, TTime&gt; MakeStage(Stream&lt;TRecord, TTime&gt; stream,
                                                     Expression&lt;Func&lt;TRecord, int&gt;&gt; inputPartitionBy,
                                                     Expression&lt;Func&lt;TRecord, int&gt;&gt; outputPartitionBy,
                                                     string name)
{
    // first we define the innards of the stage, supplying a context, a vertex factory, and a friendly name. 
    var stage = Foundry.NewStage(stream.Context, (index, parent) =&gt; new ExampleVertex&lt;TRecord, TTime&gt;(index, parent), name);

    // each new input requires a source of data, a (message, vertex) callback, and a partitioning requirement. 
    var input = stage.NewInput(stream, (message, vertex) =&gt; vertex.OnReceive(message), inputPartitionBy);

    // each new output requires a (listener, vertex) callback, and a partitioning guarantee. 
    var output = stage.NewOutput((listener, vertex) =&gt; vertex.Listeners.Add(listener), outputPartitionBy);

    return output;
}</pre></div></div></div><script>addSpecificTextLanguageTagSet('ID0EBAAAAAA');</script><p>
          In more detail, the <span sdata="cer" target="M:Microsoft.Research.Naiad.Dataflow.StandardVertices.Foundry.NewStage``2(Microsoft.Research.Naiad.Dataflow.TimeContext{``1},System.Func{System.Int32,Microsoft.Research.Naiad.Dataflow.Stage{``1},``0},System.String)"><a href="M_Microsoft_Research_Naiad_Dataflow_StandardVertices_Foundry_NewStage__2_1.htm" target="">NewStage<span id="ID0EPAHAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EPAHAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>TVertex, TTime<span id="ID0ENAHAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0ENAHAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script>(TimeContext<span id="ID0ELAHAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0ELAHAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>TTime<span id="ID0EJAHAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EJAHAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script>, Func<span id="ID0EHAHAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EHAHAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>Int32, Stage<span id="ID0EFAHAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EFAHAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>TTime<span id="ID0EDAHAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EDAHAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script>, TVertex<span id="ID0EBAHAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EBAHAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script>, String)</a></span>
          method is what Naiad uses to assemble a new stage, taking a <span sdata="cer" target="T:Microsoft.Research.Naiad.Dataflow.TimeContext`1"><a href="T_Microsoft_Research_Naiad_Dataflow_TimeContext_1.htm" target="">TimeContext<span id="ID0ECAFAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0ECAFAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>TTime<span id="ID0EAAFAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EAAFAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script></a></span> 
          from which the stage understands its place in the dataflow graph,
          a factory capable of producing vertices for each vertex index and stage,
          and a tasteful name to use in describing the vertex.
          This stage will contain many vertices constructed by the factory, but does not yet have any incoming or outgoing edges. 
          To add a new input, the <span sdata="cer" target="M:Microsoft.Research.Naiad.Dataflow.Stage`2.NewInput``1(Microsoft.Research.Naiad.Stream{``0,`1},System.Action{Microsoft.Research.Naiad.Dataflow.Message{``0,`1},`0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})"><a href="M_Microsoft_Research_Naiad_Dataflow_Stage_2_NewInput__1.htm" target="">NewInput<span id="ID0EWADAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EWADAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>TRecord<span id="ID0EUADAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EUADAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script>(Stream<span id="ID0ESADAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0ESADAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>TRecord, TTime<span id="ID0EQADAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EQADAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script>, Action<span id="ID0EOADAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EOADAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>Message<span id="ID0EMADAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EMADAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>TRecord, TTime<span id="ID0EKADAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EKADAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script>, TVertex<span id="ID0EIADAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EIADAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script>, Expression<span id="ID0EGADAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EGADAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>Func<span id="ID0EEADAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EEADAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>TRecord, Int32<span id="ID0ECADAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0ECADAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script><span id="ID0EBADAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EBADAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script>)</a></span> 
          method needs a source of data, a callback for each vertex supplied as an action  on messages and vertices, and a partitioning requirement.
          Naiad will make sure that all records passed along the input will be partitioned according to the requirement, in that two records evaluating to the same value will arrive at the same vertex instance. Once all inputs are added we can add outputs 
          using <span sdata="cer" target="M:Microsoft.Research.Naiad.Dataflow.Stage`2.NewOutput``1(System.Func{`0,Microsoft.Research.Naiad.Dataflow.VertexOutput{``0,`1}},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})"><a href="M_Microsoft_Research_Naiad_Dataflow_Stage_2_NewOutput__1_1.htm" target="">NewOutput<span id="ID0ERABAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0ERABAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>R<span id="ID0EPABAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EPABAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script>(Func<span id="ID0ENABAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0ENABAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>TVertex, VertexOutput<span id="ID0ELABAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0ELABAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>R, TTime<span id="ID0EJABAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EJABAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script><span id="ID0EIABAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EIABAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script>, Expression<span id="ID0EGABAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EGABAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>Func<span id="ID0EEABAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EEABAAAAAAA?vb=(Of |cpp=&lt;|cs=&lt;|fs=&lt;'|nu=(");
				</script>R, Int32<span id="ID0ECABAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0ECABAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script><span id="ID0EBABAAAAAAA"> </span><script type="text/javascript">
					addToLanSpecTextIdSet("ID0EBABAAAAAAA?vb=)|cpp=&gt;|cs=&gt;|fs=&gt;|nu=)");
				</script>)</a></span>,
          which requires a registration callback (essentially what the vertex should do when another vertex expresses interest in its output), and a partitioning guarantee.
          Naiad uses the guarantee to pipeline communication when an interested consumer has a requirement matching the guarantee.

        </p></div></div></div></div><div id="OH_footer" class="OH_footer"><p /><div class="OH_feedbacklink"><a href="mailto:naiadquestions@microsoft.com?subject=Naiad+Help+Implementing+a+custom+Naiad+vertex+100+EN-US&amp;body=Your%20feedback%20is%20used%20to%20improve%20the%20documentation%20and%20the%20product.%20Your%20e-mail%20address%20will%20not%20be%20used%20for%20any%20other%20purpose%20and%20is%20disposed%20of%20after%20the%20issue%20you%20report%20is%20resolved.%20While%20working%20to%20resolve%20the%20issue%20that%20you%20report%2c%20you%20may%20be%20contacted%20via%20e-mail%20to%20get%20further%20details%20or%20clarification%20on%20the%20feedback%20you%20sent.%20After%20the%20issue%20you%20report%20has%20been%20addressed%2c%20you%20may%20receive%20an%20e-mail%20to%20let%20you%20know%20that%20your%20feedback%20has%20been%20addressed.">Send Feedback</a> on this topic to naiadquestions@microsoft.com.</div></div></body></html>