<html><head><meta http-equiv="X-UA-Compatible" content="IE=edge" /><link rel="shortcut icon" href="../icons/favicon.ico" /><style type="text/css">.OH_CodeSnippetContainerTabLeftActive, .OH_CodeSnippetContainerTabLeft,.OH_CodeSnippetContainerTabLeftDisabled { }.OH_CodeSnippetContainerTabRightActive, .OH_CodeSnippetContainerTabRight,.OH_CodeSnippetContainerTabRightDisabled { }.OH_footer { }</style><link rel="stylesheet" type="text/css" href="../styles/branding.css" /><link rel="stylesheet" type="text/css" href="../styles/branding-en-US.css" /><script type="text/javascript" src="../scripts/branding.js"> </script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Implementing a custom Naiad vertex</title><meta name="Language" content="en-us" /><meta name="Microsoft.Help.Id" content="1aff01be-2d57-406e-9f1d-b0872c8733e5" /><meta name="Description" content="Naiad programs are described as dataflow graphs, where the nodes in the graph (Naiad calls them stages) correspond to computation, and the edges describe the flow of data." /><meta name="Microsoft.Help.ContentType" content="How To" /><meta name="BrandingAware" content="true" /><link type="text/css" rel="stylesheet" href="../styles/highlight.css" /><script type="text/javascript" src="../scripts/highlight.js"> </script></head><body onload="OnLoad('cs')"><input type="hidden" id="userDataCache" class="userDataStyle" /><div class="OH_outerDiv"><div class="OH_outerContent"><table class="TitleTable"><tr><td class="OH_tdLogoColumn"><img src="../icons/Help.png" /></td><td class="OH_tdTitleColumn">Implementing a custom Naiad vertex</td><td class="OH_tdRunningTitleColumn">Naiad Help</td></tr></table><div id="mainSection"><div id="mainBody"><span class="introStyle"></span><p style="color: #dc143c; font-size: 8.5pt; font-weight: bold;">[This is preliminary documentation and is subject to change.]</p><div class="introduction"><p>
        Naiad programs are described as dataflow graphs, where the nodes in the graph (Naiad calls them stages) correspond to computation, and the edges describe the flow of data. A large collection of pre-fabricated stages exist, and while most programmers will likely use these predominantly, it can also be useful to be able to understand how stages are defined in case the programmer needs to introduce custom computations.
      </p><p>
        There are two steps to implementing a custom dataflow stage: one needs to define a dataflow vertex containing the associated state and logic, and one needs to tell Naiad how to connect inputs and outputs to this logic so that input records trigger the correct computation. We will go through each of these parts, demonstrating not only how to perform these steps from the ground up, but also how Naiad has wrapped up some common patterns to try and make life easier for the programmer.
      </p></div><div class="OH_CollapsibleAreaRegion"><div class="OH_regiontitle">Defining the dataflow vertex</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"> </div><p>
          Custom vertices are defined by inheriting from the <a href="T_Microsoft_Research_Naiad_Dataflow_Vertex_1.htm">Vertex<span id="LST159366D_0"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_0?cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'");</script>TTime<span id="LST159366D_1"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_1?cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;");</script></a> class,
          which is a class wrapping the common logic for all vertices that may be brought in to existence in a Naiad stage.
          The generic parameter  <span class="code">TTime</span>  denotes the type of Naiad timestamp the vertex uses, which will often be a generic parameter
          for your custom vertex, too. We'll get to the specific features of the Vertex class later.
          An example vertex with one input and one output might look like the following
        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EABAGAAA_copyCode" href="#" onclick="javascript:CopyToClipboard('ID0EABAGAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EABAGAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-comment">// Single input, single output Naiad vertex. Each vertex must specify a time type.</span>
<span class="highlight-keyword">public</span> <span class="highlight-keyword">class</span> ExampleVertex&lt;TRecord, TTime&gt; : Vertex&lt;TTime&gt;
    <span class="highlight-keyword">where</span> TTime : Time&lt;TTime&gt;
{
    <span class="highlight-comment">// each received message is simply forwarded to any listeners.</span>
    <span class="highlight-keyword">public</span> <span class="highlight-keyword">void</span> OnReceive(Message&lt;TRecord, TTime&gt; message)
    {
        <span class="highlight-keyword">foreach</span> (<span class="highlight-keyword">var</span> listener <span class="highlight-keyword">in</span> <span class="highlight-keyword">this</span>.Listeners)
            recipient.Send(message);
    }

    <span class="highlight-comment">// list of output recipients, each of which require all sent records.</span>
    <span class="highlight-keyword">public</span> <span class="highlight-keyword">readonly</span> List&lt;SendWire&lt;TRecord, TTime&gt;&gt; Listeners;

    <span class="highlight-comment">// each vertex requires its index in the stage, and the stage itself.</span>
    <span class="highlight-keyword">public</span> ExampleVertex(<span class="highlight-keyword">int</span> index, Stage&lt;TTime&gt; stage)
        : <span class="highlight-keyword">base</span>(index, stage)
    {
        <span class="highlight-keyword">this</span>.Listeners = <span class="highlight-keyword">new</span> List&lt;SendWire&lt;TRecord, TTime&gt;&gt;();
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EABAGAAA");</script><p>
          This vertex isn't especially interesting yet,
          and it isn't even clear how this list of recipients is populated. However, assuming that we sort that out, 
          the vertex's behavior is specified: for each received message, it sends that message to every one in its list of recipients.
        </p><div class="OH_CollapsibleAreaRegion"><div class="OH_regiontitle">Building a dataflow stage</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"> </div><p>
          To complete this example, we have to assemble a stage consisting of many of these vertices, and describe how the inputs and outputs are connected.
          The standard pattern is to first create a new stage from a vertex factory, then add any number of inputs (defined by a message callback and partitioning
          requirement), and finally add any number of outputs (defined by a registration callback and partitioning guarantee). The example looks like:
        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EABAFAAA_copyCode" href="#" onclick="javascript:CopyToClipboard('ID0EABAFAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EABAFAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-comment">// constructs a stage of our ExampleVertex, and returns the associated output stream.</span>
<span class="highlight-keyword">public</span> <span class="highlight-keyword">static</span> Stream&lt;TRecord, TTime&gt; MakeStage(Stream&lt;TRecord, TTime&gt; stream,
                                                     Expression&lt;Func&lt;TRecord, <span class="highlight-keyword">int</span>&gt;&gt; inputPartitionBy,
                                                     Expression&lt;Func&lt;TRecord, <span class="highlight-keyword">int</span>&gt;&gt; outputPartitionBy,
                                                     <span class="highlight-keyword">string</span> name)
{
    <span class="highlight-comment">// first we define the innards of the stage, supplying a context, a vertex factory, and a friendly name.</span>
    <span class="highlight-keyword">var</span> stage = Foundry.NewStage(stream.Context, (index, parent) =&gt; <span class="highlight-keyword">new</span> ExampleVertex&lt;TRecord, TTime&gt;(index, parent), name);

    <span class="highlight-comment">// each new input requires a source of data, a (message, vertex) callback, and a partitioning requirement.</span>
    <span class="highlight-keyword">var</span> input = stage.NewInput(stream, (message, vertex) =&gt; vertex.OnReceive(message), inputPartitionBy);

    <span class="highlight-comment">// each new output requires a (listener, vertex) callback, and a partitioning guarantee.</span>
    <span class="highlight-keyword">var</span> output = stage.NewOutput((listener, vertex) =&gt; vertex.Listeners.Add(listener), outputPartitionBy);

    <span class="highlight-keyword">return</span> output;
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EABAFAAA");</script><p>
          In more detail, the <a href="M_Microsoft_Research_Naiad_Dataflow_StandardVertices_Foundry_NewStage__2_1.htm">NewStage<span id="LST159366D_2"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_2?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>TVertex, TTime<span id="LST159366D_3"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_3?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>(TimeContext<span id="LST159366D_4"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_4?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>TTime<span id="LST159366D_5"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_5?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, Func<span id="LST159366D_6"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_6?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>Int32, Stage<span id="LST159366D_7"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_7?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>TTime<span id="LST159366D_8"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_8?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, TVertex<span id="LST159366D_9"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_9?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, String)</a>
          method is what Naiad uses to assemble a new stage, taking a <a href="T_Microsoft_Research_Naiad_Dataflow_TimeContext_1.htm">TimeContext<span id="LST159366D_10"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_10?cs=&lt;|vb=(Of |cpp=&lt;|nu=(|fs=&lt;'");</script>TTime<span id="LST159366D_11"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_11?cs=&gt;|vb=)|cpp=&gt;|nu=)|fs=&gt;");</script></a> 
          from which the stage understands its place in the dataflow graph,
          a factory capable of producing vertices for each vertex index and stage,
          and a tasteful name to use in describing the vertex.
          This stage will contain many vertices constructed by the factory, but does not yet have any incoming or outgoing edges. 
          To add a new input, the <a href="M_Microsoft_Research_Naiad_Dataflow_Stage_2_NewInput__1.htm">NewInput<span id="LST159366D_12"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_12?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>TRecord<span id="LST159366D_13"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_13?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>(Stream<span id="LST159366D_14"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_14?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>TRecord, TTime<span id="LST159366D_15"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_15?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, Action<span id="LST159366D_16"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_16?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>Message<span id="LST159366D_17"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_17?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>TRecord, TTime<span id="LST159366D_18"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_18?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, TVertex<span id="LST159366D_19"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_19?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, Expression<span id="LST159366D_20"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_20?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>Func<span id="LST159366D_21"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_21?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>TRecord, Int32<span id="LST159366D_22"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_22?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script><span id="LST159366D_23"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_23?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>)</a> 
          method needs a source of data, a callback for each vertex supplied as an action  on messages and vertices, and a partitioning requirement.
          Naiad will make sure that all records passed along the input will be partitioned according to the requirement, in that two records evaluating to the same value will arrive at the same vertex instance. Once all inputs are added we can add outputs 
          using <a href="M_Microsoft_Research_Naiad_Dataflow_Stage_2_NewOutput__1_1.htm">NewOutput<span id="LST159366D_24"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_24?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>R<span id="LST159366D_25"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_25?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>(Func<span id="LST159366D_26"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_26?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>TVertex, VertexOutput<span id="LST159366D_27"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_27?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>R, TTime<span id="LST159366D_28"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_28?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script><span id="LST159366D_29"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_29?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, Expression<span id="LST159366D_30"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_30?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>Func<span id="LST159366D_31"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_31?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>R, Int32<span id="LST159366D_32"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_32?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script><span id="LST159366D_33"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST159366D_33?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>)</a>,
          which requires a registration callback (essentially what the vertex should do when another vertex expresses interest in its output), and a partitioning guarantee.
          Naiad uses the guarantee to pipeline communication when an interested consumer has a requirement matching the guarantee.

        </p></div></div></div></div><div id="OH_footer" class="OH_footer"><div class="OH_feedbacklink">Send comments on this topic to
        <a id="HT_MailLink" href="mailto:naiadquestions%40microsoft.com?Subject=Naiad Help">naiadquestions@microsoft.com</a></div><script type="text/javascript">
        var HT_mailLink = document.getElementById("HT_MailLink");
        var HT_mailLinkText = HT_mailLink.innerHTML;
        HT_mailLink.href += ": " + document.title + "\u0026body=" + encodeURIComponent("Your feedback is used to improve the documentation and the product. Your e-mail address will not be used for any other purpose and is disposed of after the issue you report is resolved. While working to resolve the issue that you report, you may be contacted via e-mail to get further details or clarification on the feedback you sent. After the issue you report has been addressed, you may receive an e-mail to let you know that your feedback has been addressed.");
        HT_mailLink.innerHTML = HT_mailLinkText;
        </script></div></body></html>